"An instruction can be any size (ie 8, 16, 32 bits) depending on the CPU",
"Bite – flip flop",
"Byte – 8 flip flops – standard size for RAM",
"Word – standard size for CPU",
"Address – standard size for bus",
"At least now, sizes should agree with each other",
"Program (assume 8 bit instruction set)",
"-MOV D0, D1",
"-Add D1, D0, 5		D1 = D0 + 5",
"-MOV D0, X		D0 gets x from RAM",
"Run Program",
"-OS – double click, load to RAM at free space, PC &larr; 50",
"Program Runs (OS is sleeping; number on top right denotes address)",
"-MAR<sup>50</sup> &larr; PC<sup>50</sup> <br> PC<sup>51</sup> &larr; PC + 1<sup>51</sup>",
"-AR<sup>50</sup> &larr; MAR<sup>56</sup> <br> DR &larr; RAM[AR]",
"-MBR &larr; DR <br> IR &larr; MBR <br> CU &larr; IR (op code)",
"OP code => code # represents instruction",
"Bottom left wires go down to CU",
"Args is complicated; sometimes have one, two, three, etc",
"-For our example, there is always 3 arguments",
"Comment: no real difference b/t integers and addresses; just how we use it",
"Need code for all instructions?",
"Each instruction from set is mode of micro-instructions",
"-ADD, D1, D0, 5 &rarr; D1 = D0 + 5",
"-Micro",
"--L &larr; D0",
"--R &larr; 5",
"--A &larr; ALU(L,R)",
"--D1 &larr; A",
